<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
using System;

namespace Light.Serialization.Json.TokenParsers
{
<#
	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host)
											.GetService(typeof(EnvDTE.DTE));
	XmlDocument parserDataXml = new XmlDocument();
	parserDataXml.Load(System.IO.Path.Combine(dte.ActiveDocument.Path, "IntegerParserData.xml"));
	XmlNodeList listOfPasers = parserDataXml.SelectNodes("/Parsers/Parser");
		
	foreach(XmlNode parser in listOfPasers)
	{
		string parserName = parser.SelectSingleNode("Name").InnerText;
		string parserType = parser.SelectSingleNode("Type").InnerText;
		string parserNegativeSign = parser.SelectSingleNode("NegativeSign").InnerText;

		//todo: find a better solution
		if(parserNegativeSign == "")
			parserNegativeSign = "+";

		string parserDecimalPointCharacter = parser.SelectSingleNode("DecimalPointCharacter").InnerText;
		string parserMaxAsString = parser.SelectSingleNode("MaxAsString").InnerText;
		string parserMinAsString = parser.SelectSingleNode("MinAsString").InnerText;
		#>
	public class <#= parserName #> : IJsonTokenParser
	{
		private readonly Type _integerType = typeof (<#= parserType #>);
		
        public const char DecimalPointCharacter = '<#= parserDecimalPointCharacter #>';
        public const char NegativeSign = '<#= parserNegativeSign #>';

        public const string MaxAsString = "<#= parserMaxAsString #>";
        public const string MinAsString = "<#= parserMinAsString #>";

		public bool IsSuitableFor(JsonToken token, Type requestedType)
        {
            return (token.JsonType == JsonTokenType.IntegerNumber || token.JsonType == JsonTokenType.FloatingPointNumber) && requestedType == _integerType;
        }

		public object ParseValue(JsonDeserializationContext context)
        {
            var token = context.Token;
            var decimalPointInfo = GetIndexOfDecimalPoint(token);
            var positionsBeforeDecimalPoint = token.Length;

            if (decimalPointInfo.IndexOfDecimalPoint != null)
            {
                if (decimalPointInfo.AreTrailingDigitsOnlyZeros == false)
                    throw new DeserializationException($"Could not deserialize value {token} because it is no integer, but a real number");

                positionsBeforeDecimalPoint = decimalPointInfo.IndexOfDecimalPoint.Value;
            }

            var currentIndex = 0;
            var isResultNegative = false;
            string overflowCompareString = null;

			if (NegativeSign != '+' && token[0] == NegativeSign)
            {
                if (token.Length > MinAsString.Length)
                    throw new DeserializationException($"Could not deserialize value {token} because it produces an overflow for type int.");
                if (token.Length == MinAsString.Length)
                    overflowCompareString = MinAsString;
                isResultNegative = true;

                positionsBeforeDecimalPoint--;
                currentIndex++;
            }
			else if (token.Length > MaxAsString.Length)
                throw new DeserializationException($"Could not deserialize value {token} because it produces an overflow for type int.");
            else if (token.Length == MaxAsString.Length)
                overflowCompareString = MaxAsString;

			<#= parserType #>  result = 0;
			var currentPositionBeforeDecimalPoint = positionsBeforeDecimalPoint;
            while (currentPositionBeforeDecimalPoint > 0)
            {
                <#= parserType #> digit = (<#= parserType #>)(token[currentIndex] - '0');

                if (digit > overflowCompareString?[currentIndex] - '0')
                    throw new DeserializationException($"Could not deserialize value {token} because it produces an overflow for type int.");

                result += (<#= parserType #>)(digit * CalculateBase(currentPositionBeforeDecimalPoint));

                currentIndex++;
                currentPositionBeforeDecimalPoint--;
            }

            if (isResultNegative)
                return -result;

            return result;
        }

		private static <#= parserType #> CalculateBase(int positionsBeforeDecimalPoint)
        {
            if (positionsBeforeDecimalPoint == 1)
                return 1;

            <#= parserType #> result = 10;
            for (var i = 2; i < positionsBeforeDecimalPoint; i++)
            {
                result *= 10;
            }
            return result;
        }

        private static DecimalPointInfo GetIndexOfDecimalPoint(JsonToken buffer)
        {
            var areTrailingDigitsOnlyZeros = true;
            int? indexOfDecimalPoint = null;
            int i;

            for (i = 0; i < buffer.Length; i++)
            {
                if (buffer[i] != DecimalPointCharacter) continue;

                indexOfDecimalPoint = i;
                break;
            }

            for (i++; i < buffer.Length; i++)
            {
                if (buffer[i] == '0') continue;
                areTrailingDigitsOnlyZeros = false;
                break;
            }

            return new DecimalPointInfo(indexOfDecimalPoint, areTrailingDigitsOnlyZeros);
        }

        private struct DecimalPointInfo
        {
            public readonly int? IndexOfDecimalPoint;
            public readonly bool AreTrailingDigitsOnlyZeros;

            public DecimalPointInfo(int? indexOfDecimalPoint, bool areTrailingDigitsOnlyZeros)
            {
                AreTrailingDigitsOnlyZeros = areTrailingDigitsOnlyZeros;
                IndexOfDecimalPoint = indexOfDecimalPoint;
            }
        }
    }
			<#
			}
			#>
}