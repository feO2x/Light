<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
using System;
using Xunit;
using System.Linq;

namespace Light.Serialization.Tests
{

<#
	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host)
											.GetService(typeof(EnvDTE.DTE));
	XmlDocument parserDataXml = new XmlDocument();
	parserDataXml.Load(System.IO.Path.Combine(dte.ActiveDocument.Path, @"..\Light.Serialization\Json\TokenParsers\IntegerParserData.xml"));
	XmlNodeList listOfPasers = parserDataXml.SelectNodes("/Parsers/Parser");

    foreach (XmlNode parser in listOfPasers)
    {
        _maxAsString = parser.SelectSingleNode("MaxAsString").InnerText;
		_minAsString = parser.SelectSingleNode("MinAsString").InnerText;
		string parserType = parser.SelectSingleNode("Type").InnerText;
        string parserName = parser.SelectSingleNode("Name").InnerText;
		string parserNegativeSign = parser.SelectSingleNode("NegativeSign").InnerText;

#>

    public sealed class Json<#= parserName #>DeserializationTests : BaseDefaultJsonDeserializationTest
    {
		[Theory]
        [InlineData("42", 42)]
		[InlineData(<#= parserType #>.MaxValue/2, <#= parserType #>.MaxValue/2)]
        [InlineData("<#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>", <#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>)]
        [InlineData(<#= parserType #>.MaxValue, <#= parserType #>.MaxValue)]
        [InlineData(<#= parserType #>.MinValue, <#= parserType #>.MinValue)]
		<# if (parserNegativeSign == "-") 
		{ #>[InlineData("0", 0)]
        [InlineData(<#= parserType #>.MinValue + <#= parserType #>.MaxValue/2, <#= parserType #>.MinValue + <#= parserType #>.MaxValue/2)]
		<# }#>
		
		public void IntValueCanBeDeserializedCorrectly(string json, <#= parserType #> expected)
        {
            CompareDeserializedJsonToExpected(json, expected);
        }

		[Theory]
		[InlineData("<#=IncrementMaxValueInString()#>")] //<#= parserType #> max value ( <#= _maxAsString #> ) +1
        [InlineData("<#=DecrementMinValueInString()#>")]
        [InlineData("<#=IncrementSecondLeftMostNumberInString()#>")]
        [InlineData("<#=IncrementLeftMostNumberInString()#>")]
        [InlineData("<#=_maxAsString#>00000000")]

        public void ExceptionIsThrownWhenOverflowingIntValueIsDeserialized(string json)
        {
            CheckDeserializerThrowsExceptionWithMessage<<#= parserType #>>(json, $"Could not deserialize value {json} because it produces an overflow for type <#= parserType #>.");
		}

		[Theory]
        [InlineData("42.0", 42)]
        [InlineData("<#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>.000", <#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>)]
        [InlineData("<#= _maxAsString #>.0000", <#= parserType #>.MaxValue)]
        [InlineData("<#= _minAsString #>.00000", <#= parserType #>.MinValue)]
		<# if (parserNegativeSign == "-") 
		{ #>[InlineData("0.0", 0)]
		<# }#>
		
		public void NumbersWithTrailingZerosAfterDecimalPointCanBeDeserialized(string json, <#= parserType #> expected)
        {
            CompareDeserializedJsonToExpected(json, expected);
        }

		        [Theory]
        [InlineData("42.7")]
        [InlineData("<#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>.007")]
        [InlineData("<#= _maxAsString #>.0353")]
        [InlineData("0.00000856")]
		[InlineData("<#= _minAsString #>.000000001")]

        public void ExceptionIsThrownWhenNumbersWithNonZeroDigitsAfterDecimalPointIsDeserialized(string json)
        {
            CheckDeserializerThrowsExceptionWithMessage<int>(json, $"Could not deserialize value {json} because it is no integer, but a real number");
        }

	}
	<# } #>
}

<#+
    private string _maxAsString;
    private string _minAsString;

	private string IncrementSecondLeftMostNumberInString()
    {
	    int i = 1;

        if(_maxAsString.All(c => !char.IsDigit(c) && (c != '-')))
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();

        if (numberArray[0] == '-')
            i++;

        if (numberArray[i] == '9')
        {
            numberArray[i] = '0';
            var numberString = new string(numberArray);
            return "1" + numberString;
        }

        numberArray[i] = (char)(numberArray[i] + 1);

		return new string(numberArray);
    }

    private string IncrementLeftMostNumberInString()
    {
	    int i = 0;

        if(_maxAsString.All(c => !char.IsDigit(c) && (c != '-')))
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();

        if (numberArray[0] == '-')
            i++;

        if (numberArray[i] == '9')
        {
            numberArray[i] = '0';
            var numberString = new string(numberArray);
            return "1" + numberString;
        }

        numberArray[i] = (char)(numberArray[i] + 1);

		return new string(numberArray);
    }

    private string DecrementLeftMostIncrementSecondLeftMostNumberInString()
    {
        int i = 0;
        if(_maxAsString.All(c => !char.IsDigit(c) && (c != '-')))
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();

        if (numberArray[0] == '-')
            i++;

        if (numberArray[i] == '1')
            numberArray = _maxAsString.Remove(0, 1).ToArray();
        else
		{
            numberArray[i] = (char)(numberArray[0] - 1);
		    i++;
		}

        if (numberArray[i] == '9')
        {
            numberArray[i] = '0';
            if (numberArray[0] == '9')
            {
                numberArray[0] = '0';
                var numbers = new string(numberArray);
                return "1" + numbers;
            }

            numberArray[i] = (char)((int)numberArray[i] + 1);
            return new string(numberArray);
        }

        numberArray[i] = (char)((int)numberArray[i] + 1);

        return new string(numberArray);
    }

    private string DecrementMinValueInString()
    {
        return IncrementNumberInString(_minAsString);
    }

    private string IncrementMaxValueInString()
    {
        return IncrementNumberInString(_maxAsString);
    }

	private string IncrementNumberInString(string number)
	{
	    if (number == "0")
	        return "-1";
		
		if(number.All(c =>  !char.IsDigit(c) && (c != '-')))
			throw new ArgumentException("number must contain digits only.");

		var numberArray = number.ToCharArray();
		int i = numberArray.Length -1;
		int numberToIncrement = 0;
		int borrow = 0;

	    if (numberArray[0] == '-')
	        i--;

		while(i >= 0)
		{
			if(numberArray[i] != 9 || (numberArray[i] + borrow) != 9)
			{
				int.TryParse(numberArray[i].ToString(), out numberToIncrement);
				var numberIncrementend = ++numberToIncrement + borrow;
				borrow = 0;
			    char result;
				Char.TryParse(numberIncrementend.ToString(), out result);
			    numberArray[i] = result;

				return new string(numberArray);
			} else {
				int.TryParse(numberArray[i].ToString(), out numberToIncrement);
				var numberIncrementend = ++numberToIncrement + borrow;
				borrow = 1;
				if(numberIncrementend == 10)
					numberArray[i] = '0';
			}
			i--;
		}

            return "1" + numberArray;
    }#>