<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>
using System;
using Xunit;
using System.Linq;

namespace Light.Serialization.Tests
{

<#
	EnvDTE.DTE dte = (EnvDTE.DTE) ((IServiceProvider) this.Host)
											.GetService(typeof(EnvDTE.DTE));
	XmlDocument parserDataXml = new XmlDocument();
	parserDataXml.Load(System.IO.Path.Combine(dte.ActiveDocument.Path, @"..\Light.Serialization\Json\TokenParsers\IntegerParserData.xml"));
	XmlNodeList listOfPasers = parserDataXml.SelectNodes("/Parsers/Parser");

    foreach (XmlNode parser in listOfPasers)
    {
        _maxAsString = parser.SelectSingleNode("MaxAsString").InnerText;
		string parserType = parser.SelectSingleNode("Type").InnerText;
        string parserName = parser.SelectSingleNode("Name").InnerText;
		string parserNegativeSign = parser.SelectSingleNode("NegativeSign").InnerText;

#>

    public sealed class Json<#= parserName #>DeserializationTests : BaseDefaultJsonDeserializationTest
    {
		[Theory]
        [InlineData("42", 42)]
		[InlineData(<#= parserType #>.MaxValue/2, <#= parserType #>.MaxValue/2)]
        [InlineData("<#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>", <#= DecrementLeftMostIncrementSecondLeftMostNumberInString() #>)]
        [InlineData(<#= parserType #>.MaxValue, <#= parserType #>.MaxValue)]
        [InlineData(<#= parserType #>.MinValue, <#= parserType #>.MinValue)]
		<# if (parserNegativeSign == "-") 
		{ #>[InlineData("0", 0)]
        [InlineData(<#= parserType #>.MinValue + <#= parserType #>.MaxValue/2, <#= parserType #>.MinValue + <#= parserType #>.MaxValue/2)]
		<# }#>
		
		public void IntValueCanBeDeserializedCorrectly(string json, <#= parserType #> expected)
        {
            CompareDeserializedJsonToExpected(json, expected);
        }

		[Theory]
		[InlineData("<#=IncrementNumberInString()#>")] //<#= parserType #> max value ( <#= _maxAsString #> ) +1
        //[InlineData("2247483647")]
        //[InlineData("-2147483649")]
        //[InlineData("-2247483648")]
        [InlineData("<#=IncrementLeftMostNumberInString()#>")]
        //[InlineData("-375000000000")]

        public void ExceptionIsThrownWhenOverflowingIntValueIsDeserialized(string json)
        {
            CheckDeserializerThrowsExceptionWithMessage<<#= parserType #>>(json, $"Could not deserialize value {json} because it produces an overflow for type <#= parserType #>.");
		}

	}
	<# } #>
}

<#+
    private string _maxAsString;

    private string IncrementLeftMostNumberInString()
    {
        if(_maxAsString.All(c => char.IsDigit(c)) == false)
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();

        if (numberArray[0] == '9')
        {
            numberArray[0] = '0';
            var numberString = new string(numberArray);
            return "1" + numberString;
        }

        numberArray[0]++;

		return new string(numberArray);
    }

    private string DecrementLeftMostIncrementSecondLeftMostNumberInString()
    {
        if(_maxAsString.All(c => char.IsDigit(c)) == false)
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();

        if (numberArray[0] == '1')
            numberArray = _maxAsString.Remove(0, 1).ToArray();
        else
            numberArray[0] = (char)(numberArray[0] - 1);

        if (numberArray[1] == '9')
        {
            numberArray[1] = '0';
            if (numberArray[0] == '9')
            {
                numberArray[0] = '0';
                var numbers = new string(numberArray);
                return "1" + numbers;
            }

            numberArray[0]++;
            return new string(numberArray);
        }

        numberArray[1]++;

        return new string(numberArray);
    }

	private string IncrementNumberInString()
    {
		if(_maxAsString.All(c => char.IsDigit(c)) == false)
			throw new ArgumentException("number must contain digits only.");

		var numberArray = _maxAsString.ToCharArray();
		int i = numberArray.Length -1;
		int numberToIncrement = 0;
		int borrow = 0;

		while(i >= 0)
		{
			if(numberArray[i] != 9 || (numberArray[i] + borrow) != 9)
			{
				int.TryParse(numberArray[i].ToString(), out numberToIncrement);
				var numberIncrementend = ++numberToIncrement + borrow;
				borrow = 0;
			    char result;
				Char.TryParse(numberIncrementend.ToString(), out result);
			    numberArray[i] = result;

				return new string(numberArray);
			} else {
				int.TryParse(numberArray[i].ToString(), out numberToIncrement);
				var numberIncrementend = ++numberToIncrement + borrow;
				borrow = 1;
				if(numberIncrementend == 10)
					numberArray[i] = '0';
			}
			i--;
		}

            return "1" + numberArray;
    }#>